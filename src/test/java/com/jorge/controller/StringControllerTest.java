package com.jorge.controller;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.forwardedUrl;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.model;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.testng.AbstractTestNGSpringContextTests;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;
import org.testng.annotations.BeforeMethod;
import org.testng.annotations.Test;

import com.jorge.config.AppConfig;

/**
 * Unit testing controller methods
 * 
 * Unit testing the logic of controller methods is usually difficult, but Spring makes it easy by providing
 * methods to simulate a request and test the response generated by Spring.
 * 
 * The setup() method is executed before each test method is executed.
 * In the setup() method, MockMvcBuilders.webAppContextSetup performs a full initialization of
 * the controllers and their dependencies, allowing this.mockMvc.perform() to retrieve the right
 * controller for a given URL.
 *
 */
@ContextConfiguration(classes = {AppConfig.class}) // Loads the Spring configuration class and makes the class's beans available
@WebAppConfiguration // Prevents exceptions from being raised. Without it, @EnableWebMvc (in theSpring configuration) would raise the "A ServletContext is required to configure default servlet handling" exception
public class StringControllerTest extends AbstractTestNGSpringContextTests{ // "extends AbstractTestNGSpringContextTests" is necessary to avoid this error: WebApplicationContext is required
	
	@Autowired
	private WebApplicationContext wac; // Necessary for unit testing controller methods
	private MockMvc mockMvc; // Necessary for unit testing controller methods
	
	@BeforeMethod // If you are using JUnit, use the @Before annotation
	public void setup() {
		this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();
	}
	
	/**
	 * In the test method, we will build a POST request with the parameters a and b , execute that
	 * request, and test whether the web application responds to that URL, if the proper String is set
	 * in the model, and whether the right JSP is used
	 * 
	 * Explore the MockMvcRequestBuilders class to find more elements that can be tested at
	 * 		http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/request/MockMvcRequestBuilders.html.
	 * 
	 * For example, you can test that a GET request gets some JSON content as response, and check the
	 * value of a specific element of the response.
	 * 		this.mockMvc.perform(get("/user/5"))
	 * 		.andExpect(content().contentType("application/json"))
	 * 		.andExpect(jsonPath("$.firstName").value("Scott."));
	 * 
	 */
	@Test
	public void testTest1() throws Exception {
		this.mockMvc.perform(post("/concat").param("a", "red").param("b", "apple")) // POST request. In controller method it could be GET request and test it with POST request. Check concat() method in StringController.java
		//this.mockMvc.perform(get("/concat").param("a", "red").param("b", "apple")) // GET request
		.andExpect(status().isOk())
		.andExpect(model().attribute("result", "redapple"))
		.andExpect(forwardedUrl("/WEB-INF/jsp/concat.jsp"))
		.andDo(MockMvcResultHandlers.print()); // This is for debugging, to print the detailed information about the request and the response
	}
}
